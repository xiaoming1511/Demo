##   js的数据类型

- 基本数据类型：string、number、Boolean、undefined、null、Bigint、Symbol
- 复杂数据类型：Array、Object、function

## vue的生命周期

- vue2：
  - beforeCreate：创建前
  - Created：创建后
  - beforeMount：挂载前
  - Mounted：挂载后
  - beforeUpdate：修改前
  - Updated：修改后
  - beforeDestroy：销毁前
  - Destroyed：销毁后
- vue3：
  - onBeforeMount：挂载前
  - onMounted：挂载后
  - onbeforeUpdate：修改前
  - onUpdated：修改后
  - onBeforeUnmount：卸载前
  - onUnmounted：卸载后

## **vue的组件通信方式**

- props
- event Bus
- vuex
- $emit
- $refs
- provide / inject 为依赖注入

## v-if和v-show的区别

- [v-if]()通过[条件]()来控制动态添加dom元素；[v-show]()通过css的[display：none]()来控制元素显示。
- if会根据逻辑值判断组件是否解析,[show始终会解析]()。
- [v-if初始化性能更好]()，[v-show切换性能更好]()。
- v-show是控制displasy；[v-if是创建组件和销毁组件，会调用生命周期

## js 闭包

内部函数能够访问到外部函数中变量，在外部函数执行结束后变量没有被销毁，这个内部函数被称为闭包；但是会造成内存泄漏，解决的办法是在调用结束后将函数设置为 null；使用场景防抖节流

```javascript
function createGreeting(greeting) {
  return function(name) {
    console.log(greeting + ', ' + name);
  };
}

const greetHello = createGreeting('Hello');
greetHello('Alice'); // 输出: Hello, Alice
greetHello('Bob'); // 输出: Hello, Bob
```

## css 响应式布局

- @media ：媒体查询
- 流式布局：使用百分比
- 弹性盒子：使用flex
- 相对单位：使用rem\vw

## mysql主键和唯一键的区别

- **主键**：一张表中只能有一个主键。主键的目的是唯一标识表中的每一行数据。不允许NULL值
- **唯一键**：一张表中可以有多个唯一键。唯一键保证列中的每个值都是不重复的，允许有NULL值

## 说一说跨域是什么？如何解决跨域问题？

- 跨域：当前页面中的某个接口请求的地址和当前页面的地址如果协议、域名、端口其中有一项不同，就说该接口跨域了；原因是浏览器为了保证网页的安全，出的同源协议策略。
- 解决方案：后端设置\前端配置响应头
  - cors：目前最常用的一种解决办法，通过设置后端允许跨域实现。
  - res.setHeader('Access-Control-Allow-Origin', '*');
  - res.setHeader("Access-Control-Allow-Methods", "GET, PUT, OPTIONS, POST");

## 说一说事件循环Event loop，宏任务与微任务？

遇见同步任务，直接推入调用栈中执行，遇到异步任务，将该任务挂起，等到异步任务有返回之后推入到任务队列中，当调用栈中的所有同步任务全部执行完成，将任务队列中的任务按顺序一个一个的推入并执行，重复执行这一系列的行为。

- 异步任务：
  - 宏任务：script标签代码、setTimeout/setInterval定时器、Ajax请求
  - 微任务：Promise、nextTick

## 语义化的HTML

- `<header>`元素来包裹导航链接和网站标题。
- `<nav>`元素来定义导航链接的集合。
- `<footer>`元素来定义页脚，包含版权信息、联系方式等。
- `<aside>`元素来标记与页面主要内容相关但又相对独立的内容，如侧边栏。
- `<title>`：页面主体内容
- `<main>`：页面主要内容，一个页面只能使用一次。如果是web应用，则包围其主要功能。

## 样式优先级

```css
!important > style > id > class(:hover) > 标签(伪元素(::before)、后代(.father .child) > 子类(.father > .child)、相邻(.bro1 + .bro2)) > 通配符(*)
```

### 未知宽高元素水平垂直居中方法

1. Flexbox

   ```css
   .parent {
     display: flex;
     justify-content: center;
     align-items: center;
   }
   ```

   

2. 绝对定位

   ```css
   .parent {
     position: relative;
   }
   .children {
     position: absolute;
     top: 50%;
     left: 50%;
     transform: translate(-50%, -50%);
   }
   ```

   

3. 绝对定位+外边距

   ```css
   .parent {
     position: relative;
   }
   .children {
     position: absolute;
     top: 0;
     left: 0;
     right: 0;
     bottom: 0;
     margin: auto;
   }
   ```

   

